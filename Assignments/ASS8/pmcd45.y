%{
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int i=0,index1=0,tindex=0;
void addqruple(char op[5],char arg1[10],char arg2[10],char result[10]);
int yylex();
int yyerror();
struct q
{
      char op[5];
      char arg1[10];
      char arg2[10];
      char result[10];
}q[30];

%}

%union
{
  char var[10];
}

%token <var>NUM VAR 
%type <var>EXPR ASSIGNMENT 
%left'-''+'
%left'*''/'
%nonassoc UMINUS
%left '('')'

%%

ASSIGNMENT:VAR'='EXPR {
           	strcpy(q[index1].op,"=");
           	strcpy(q[index1].arg1,$3);
           	strcpy(q[index1].arg2,"");
           	strcpy(q[index1].result,$1);
           	strcpy($$,q[index1++].result);
            	}
            ;
EXPR:EXPR'+'EXPR {addqruple("+",$1,$3,$$);}
    |EXPR'-'EXPR {addqruple("-",$1,$3,$$);}
    |EXPR'*'EXPR {addqruple("*",$1,$3,$$);}
    |EXPR'/'EXPR {addqruple("/",$1,$3,$$);}
    |'('EXPR')'EXPR {strcpy($$,$2);}
    |'-'EXPR {addqruple("uminus",$2,"",$$);}
    |VAR
    |NUM
    ;

%%

int main()
{

yyparse();
printf("\n\nthree address code");
for(i=0;i<index1;i++)
{
 printf("\n %s\t %c\t %s\t %s\t %s\n",q[i].result, '=', q[i].arg1,q[i].op,q[i].arg2);
}
printf("\n\nINDEX\t OP\t ARG1\t ARG2\t RESULT");
for(i=0;i<index1;i++)
{
 printf("\n%d\t %s\t %s\t %s\t %s\n",i,q[i].op,q[i].arg1,q[i].arg2,q[i].result);
}
return 0;
}
void addqruple(char op[5],char arg1[10],char arg2[10],char result[10])
 {
 strcpy(q[index1].op,op);
 strcpy(q[index1].arg1,arg1);
 strcpy(q[index1].arg2,arg2);
 sprintf(q[index1].result,"t%d",tindex++);
 strcpy(result,q[index1++].result);  
 }

int yyerror()
{ 
printf("syntax error");
}
int yywrap()
{
return 1;
}


//lex pmcd45.l
//yacc -d pmcd45.y
//cc lex.yy.c y.tab.c
//./a.out
//out put is type manullay 
//eg:- a=b+c*d $
//a=b+c*d;

/*
%{
#include "y.tab.h"    // Include the header file generated by Yacc/Bison which contains token definitions
#include "stdio.h"    // Include standard I/O library for printing
#include "string.h"   // Include string library for string operations
#include "stdlib.h"   // Include standard library for functions like malloc

int i = 0, index1 = 0, tindex = 0;  // Initialize global variables
void addqruple(char op[5], char arg1[10], char arg2[10], char result[10]);  // Declare function for adding quadruples
int yylex();    // Declare yylex function (Lexical analyzer)
int yyerror();  // Declare yyerror function (Error handler)

// Define a structure for the quadruples
struct q {
      char op[5];
      char arg1[10];
      char arg2[10];
      char result[10];
} q[30];  // Array of structures to store up to 30 quadruples
%}

%union {
  char var[10];  // Union type to hold variable values as strings
}

%token <var> NUM VAR  // Define tokens with associated types
%type <var> EXPR ASSIGNMENT  // Define non-terminals with associated types
%left '-' '+'  // Define left-associative operators for + and -
%left '*' '/'  // Define left-associative operators for * and /
%nonassoc UMINUS  // Define non-associative unary minus operator
%left '(' ')'  // Define precedence for parentheses

%%

// Define the grammar rules and actions
ASSIGNMENT: VAR '=' EXPR {
            strcpy(q[index1].op, "=");  // Set operator to '='
            strcpy(q[index1].arg1, $3);  // Set the first argument to the value of the expression
            strcpy(q[index1].arg2, "");  // Set the second argument to an empty string
            strcpy(q[index1].result, $1);  // Set the result to the variable name
            strcpy($$, q[index1++].result);  // Update result and increment index
          }
        ;
EXPR: EXPR '+' EXPR {addqruple("+", $1, $3, $$);}  // Addition operation
    | EXPR '-' EXPR {addqruple("-", $1, $3, $$);}  // Subtraction operation
    | EXPR '*' EXPR {addqruple("*", $1, $3, $$);}  // Multiplication operation
    | EXPR '/' EXPR {addqruple("/", $1, $3, $$);}  // Division operation
    | '(' EXPR ')' {strcpy($$, $2);}  // Parentheses for grouping
    | '-' EXPR %prec UMINUS {addqruple("uminus", $2, "", $$);}  // Unary minus operation
    | VAR {strcpy($$, $1);}  // Variable
    | NUM {strcpy($$, $1);}  // Number
    ;
%%

// Main function
int main() {
    yyparse();  // Start parsing
    printf("\n\nThree address code");
    for(i = 0; i < index1; i++) {
        printf("\n %s\t %c\t %s\t %s\t %s\n", q[i].result, '=', q[i].arg1, q[i].op, q[i].arg2);
    }
    printf("\n\nINDEX\t OP\t ARG1\t ARG2\t RESULT");
    for(i = 0; i < index1; i++) {
        printf("\n%d\t %s\t %s\t %s\t %s\n", i, q[i].op, q[i].arg1, q[i].arg2, q[i].result);
    }
    return 0;
}

// Function to add a quadruple
void addqruple(char op[5], char arg1[10], char arg2[10], char result[10]) {
    strcpy(q[index1].op, op);  // Copy operator
    strcpy(q[index1].arg1, arg1);  // Copy first argument
    strcpy(q[index1].arg2, arg2);  // Copy second argument
    sprintf(q[index1].result, "t%d", tindex++);  // Generate a temporary result name
    strcpy(result, q[index1++].result);  // Update result and increment index
}

// Error handling function
int yyerror() { 
    printf("Syntax error");
}

// Wrap-up function for the end of input
int yywrap() {
    return 1;
}


Detailed Explanation:
Header Section (%{ ... %}):

Include Statements:
#include "y.tab.h": Includes the header file generated by Yacc/Bison, which typically contains token type definitions and the union for yylval.
#include "stdio.h": Includes the standard I/O library, allowing the use of functions like printf.
#include "string.h": Includes the string handling library, allowing the use of functions like strcpy.
#include "stdlib.h": Includes the standard library, providing functions like malloc.
Global Variables:
int i = 0, index1 = 0, tindex = 0;: Initializes global variables used for indexing and temporary variable generation.
Function Declarations:
void addqruple(char op[5], char arg1[10], char arg2[10], char result[10]);: Declares the function for adding quadruples.
int yylex();: Declares the lexical analyzer function.
int yyerror();: Declares the error handling function.
Structure Definition:
struct q { ... } q[30];: Defines a structure for quadruples and creates an array to store up to 30 quadruples.
Definitions Section:

Union:
%union { char var[10]; }: Defines a union type for semantic values, holding variable values as strings.
Tokens and Types:
%token <var> NUM VAR: Defines tokens with associated types.
%type <var> EXPR ASSIGNMENT: Defines non-terminals with associated types.
Operator Precedence:
%left '-' '+': Defines left-associative operators for addition and subtraction.
%left '*' '/': Defines left-associative operators for multiplication and division.
%nonassoc UMINUS: Defines a non-associative unary minus operator.
%left '(' ')': Defines precedence for parentheses.
Rules Section:

Assignment Rule:
ASSIGNMENT: VAR '=' EXPR { ... }: Matches assignment statements and adds a corresponding quadruple.
Expression Rules:
EXPR: EXPR '+' EXPR { ... }: Matches addition expressions and adds a corresponding quadruple.
EXPR: EXPR '-' EXPR { ... }: Matches subtraction expressions and adds a corresponding quadruple.
EXPR: EXPR '*' EXPR { ... }: Matches multiplication expressions and adds a corresponding quadruple.
EXPR: EXPR '/' EXPR { ... }: Matches division expressions and adds a corresponding quadruple.
EXPR: '(' EXPR ')' { ... }: Matches expressions in parentheses.
EXPR: '-' EXPR %prec UMINUS { ... }: Matches unary minus expressions and adds a corresponding quadruple.
EXPR: VAR { ... }: Matches variables.
EXPR: NUM { ... }: Matches numbers.
Auxiliary Functions:

main Function:
Starts the parser, prints the three-address code and symbol table.
addqruple Function:
Adds a quadruple to the q array, generates temporary variables.
yyerror Function:
Handles syntax errors.
yywrap Function:
Indicates the end of input.
Compilation and Execution:
Create the Lex File (pmcd45.l):

lex
Copy code
// Paste the provided Lex code here
Create the Yacc File (pmcd45.y):

yacc
Copy code
// Paste the provided Yacc code here
Generate the C Source Files:

bash
Copy code
lex pmcd45.l
yacc -d pmcd45.y
Compile the Generated C Files:

bash
Copy code
gcc lex.yy.c y.tab.c -o parser
Run the Parser:

bash
Copy code
./parser
Provide Input Manually:

text
Copy code
a=b+c*d$
The parser will process the input, generate the three-address code, and print the symbol table.

*/


